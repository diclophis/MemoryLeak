//
//  CreateSuperEllipse.m
//  AppleCoder-OpenGLES-00
//
//  Created by Jon Bardin on 9/4/09.
//  Copyright 2009 __MyCompanyName__. All rights reserved.
//

#include "paulslib.h"

#include "CreateSuperEllipse.h"


/*
 Create a superellipse
 "method" is 0 for quads, 1 for triangles
 (quads look nicer in wireframe mode)/
 This is a "unit" ellipsoid (-1 to 1) at the origin,
 glTranslate() and glScale() as required.
 */
void CreateSuperEllipse(double power1,double power2,int n,int method)
{
	int i,j;
	double theta1,theta2,theta3;
	XYZ p,p1,p2,en;
	double delta;
	
	/* Shall we just draw a point? */
	if (n < 4) {
		//glBegin(GL_POINTS);
		//glVertex3f(0.0,0.0,0.0);
		//glEnd();
		return;
	}
	
	
	NSString *verts = @"const GLfloat seVertices[] = {";
	NSString *norms = @"const GLfloat seNormals[] = {";

	
	/* Shall we just draw a plus */
	if (power1 > 10 && power2 > 10) {
		//glBegin(GL_LINES);
		//glVertex3f(-1.0, 0.0, 0.0);
		//glVertex3f( 1.0, 0.0, 0.0);
		//glVertex3f( 0.0,-1.0, 0.0);
		//glVertex3f( 0.0, 1.0, 0.0);
		//glVertex3f( 0.0, 0.0,-1.0);
		//glVertex3f( 0.0, 0.0, 1.0);
		//glEnd();
		return;
	}
	
	delta = 0.01 * TWOPI / n;
	
	int totalVerts = 0;
	
	for (j=0;j<n/2;j++) {
		theta1 = j * TWOPI / (double)n - PID2;
		theta2 = (j + 1) * TWOPI / (double)n - PID2;
		
		//if (method == 0)
		//	//glBegin(GL_QUAD_STRIP);
		//	NSLog(@"quads");
		//else
		//	//glBegin(GL_TRIANGLE_STRIP);
		//	NSLog(@"triangles");
		
			
		for (i=0;i<=n;i++) {
			if (i == 0 || i == n)
				theta3 = 0;
			else
				theta3 = i * TWOPI / n;
			
			EvalSuperEllipse(theta2,theta3,power1,power2,&p);
			EvalSuperEllipse(theta2+delta,theta3,power1,power2,&p1);
			EvalSuperEllipse(theta2,theta3+delta,power1,power2,&p2);
			en = CalcNormal(p1,p,p2);
			//glNormal3f(en.x,en.y,en.z);
			//glTexCoord2f(i/(double)n,2*(j+1)/(double)n);
			//glVertex3f(p.x,p.y,p.z);
			//NSLog(@"%f, %f, %f,", p.x,p.y,p.z);
			norms = [norms stringByAppendingFormat:@"%f, %f, %f,", en.x,en.y,en.z];
			verts = [verts stringByAppendingFormat:@"%f, %f, %f,", p.x,p.y,p.z];
			totalVerts++;
			
			EvalSuperEllipse(theta1,theta3,power1,power2,&p);
			EvalSuperEllipse(theta1+delta,theta3,power1,power2,&p1);
			EvalSuperEllipse(theta1,theta3+delta,power1,power2,&p2);
			en = CalcNormal(p1,p,p2);
			
			//glNormal3f(en.x,en.y,en.z);
			//glTexCoord2f(i/(double)n,2*j/(double)n);
			//glVertex3f(p.x,p.y,p.z);
			//NSLog(@"%f, %f, %f,", p.x,p.y,p.z);
			norms = [norms stringByAppendingFormat:@"%f, %f, %f,", en.x,en.y,en.z];
			verts = [verts stringByAppendingFormat:@"%f, %f, %f,", p.x,p.y,p.z];
			totalVerts++;

		}
		//glEnd();
	}
	//NSLog(@"};");
	NSLog(verts);
	NSLog(norms);
	NSLog(@"totalVerts: %d", totalVerts);
}

void EvalSuperEllipse(double t1,double t2,double p1,double p2,XYZ *p)
{
	double tmp;
	double ct1,ct2,st1,st2;
	
	ct1 = cos(t1);
	ct2 = cos(t2);
	st1 = sin(t1);
	st2 = sin(t2);
	
	tmp  = SIGN(ct1) * pow(fabs(ct1),p1);
	p->x = tmp * SIGN(ct2) * pow(fabs(ct2),p2);
	p->y = SIGN(st1) * pow(fabs(st1),p1);
	p->z = tmp * SIGN(st2) * pow(fabs(st2),p2);
}